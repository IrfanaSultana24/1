<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>üë∑‚Äç‚ôÄÔ∏è Farewell Runner</title>
<style>
  :root{
    --bg1:#0f172a; --bg2:#1e293b;
    --card:#0b1220cc; --text:#e2e8f0; --muted:#9fb0c3; --border:#1f2a44; --accent:#30c48d;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0}
  body{
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, "Helvetica Neue", Arial;
    color:var(--text);
    display:grid; align-content:start; justify-items:center; gap:12px;
    background: radial-gradient(1200px 800px at 10% 10%, var(--bg2), var(--bg1));
    background-size:cover; background-position:center; background-attachment:fixed;
    overflow:hidden;
    padding:16px 10px 24px;
  }

  .card{
    width:min(92vw, 820px);
    background:var(--card);
    border:1px solid var(--border);
    border-radius:18px; padding:18px 18px 14px;
    box-shadow:0 20px 40px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.05);
    backdrop-filter: blur(10px);
  }
  h1{ margin:0 0 6px; font-size:clamp(22px,4.5vw,32px); line-height:1.15 }
  .msg{ margin:0; color:var(--muted); font-size:clamp(14px,2.5vw,16px) }

  .wrap{
    position:relative;
    width:min(96vw, 900px);
    aspect-ratio: 9 / 3;                 /* responsive, ~900x300 */
    border:1px solid var(--border);
    border-radius:16px; overflow:hidden;
    box-shadow:0 20px 50px rgba(0,0,0,.35);
    background:linear-gradient(#0c1526, #0a1220);
  }

  canvas{ width:100%; height:100%; display:block; background:transparent }

  /* HUD */
  .hud{
    position:absolute; left:10px; top:10px; z-index:2;
    display:flex; gap:8px; flex-wrap:wrap; align-items:center;
    background:#0b1220cc; border:1px solid var(--border); border-radius:12px; padding:6px 8px;
    font-size:12px; backdrop-filter: blur(8px);
  }
  .pill{ padding:4px 8px; border:1px solid #2b3b52; border-radius:10px; background:#0e1728 }
  .accent{ border-color:#2e5a4c }
  .controls{
    position:absolute; right:10px; top:10px; z-index:2; display:flex; gap:8px; flex-wrap:wrap;
    background:#0b1220cc; border:1px solid var(--border); border-radius:12px; padding:6px 8px; font-size:12px; backdrop-filter: blur(8px);
  }
  .controls button{
    appearance:none; border:1px solid #334155; background:#0b1220; color:var(--text);
    padding:8px 10px; border-radius:10px; font-weight:600; cursor:pointer;
  }
  .controls button:hover{ border-color:#475569 }

  /* Mobile controls */
  .touch{
    position:absolute; inset:auto 0 8px 0; z-index:2; display:flex; gap:10px; justify-content:center;
    pointer-events:none;  /* let canvas receive events; buttons will enable pointer-events */
  }
  .touch button{
    pointer-events:auto;
    min-width:88px; padding:12px 14px; border-radius:12px;
    border:1px solid #334155; background:#0b1220cc; color:var(--text); font-weight:700;
  }

  /* Toast */
  .toast{
    position:absolute; left:50%; bottom:14px; transform:translateX(-50%);
    background:#0b1220cc; border:1px solid var(--border); border-radius:12px; padding:8px 12px; font-weight:700;
    box-shadow:0 12px 30px rgba(0,0,0,.35); backdrop-filter: blur(8px);
    opacity:0; transition:opacity .25s ease, transform .25s ease; z-index:3; pointer-events:none;
  }
  .toast.show{ opacity:1; transform:translateX(-50%) translateY(-6px) }

  /* Legend strip */
  .legend{ margin-top:4px; font-size:12px; opacity:.8 }
</style>
</head>
<body>
  <div class="card">
    <h1>Thank you, team!</h1>
    <p class="msg">It‚Äôs been a privilege to build, iterate, and ship with you. Wishing you smooth workflows and zero clashes ahead.</p>
    <p class="legend">Controls: <b>Space/‚Üë Jump</b>, <b>‚Üì Duck</b>, <b>H Help</b>, <b>P Pause</b>, <b>R Restart</b>. Catch crane help to fly across big potholes.</p>
  </div>

  <div class="wrap" id="wrap">
    <canvas id="game" aria-label="Construction runner game"></canvas>

    <div class="hud" id="hud">
      <span class="pill">Score: <b id="score">0</b></span>
      <span class="pill">Speed: <b id="speed">1.0x</b></span>
      <span class="pill">Lives: <b id="lives">‚õëÔ∏è‚õëÔ∏è‚õëÔ∏è</b></span>
      <span class="pill accent">Best: <b id="best">0</b></span>
    </div>

    <div class="controls">
      <button id="playBtn">‚ñ∂Ô∏è Play</button>
      <button id="helpBtn">üÜò Help (Crane)</button>
      <button id="pauseBtn">‚è∏Ô∏è Pause</button>
      <button id="restartBtn">üîÅ Restart</button>
    </div>

    <div class="touch">
      <button id="jumpT">‚§¥Ô∏è Jump</button>
      <button id="duckT">‚Üß Duck</button>
      <button id="helpT">üÜò Help</button>
    </div>

    <div class="toast" id="toast"></div>
  </div>

<script>
(() => {
  /* ---------- Canvas & sizing ---------- */
  const canvas = document.getElementById('game');
  const wrap = document.getElementById('wrap');
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1)); // cap DPR to keep perf
  function resize(){
    const w = wrap.clientWidth, h = wrap.clientHeight;
    canvas.width  = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    canvas.style.width = w + "px";
    canvas.style.height= h + "px";
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  const ctx = canvas.getContext('2d');
  resize(); window.addEventListener('resize', resize);

  /* ---------- UI elements ---------- */
  const scoreEl = document.getElementById('score');
  const speedEl = document.getElementById('speed');
  const livesEl = document.getElementById('lives');
  const bestEl  = document.getElementById('best');
  const toast   = document.getElementById('toast');

  const playBtn = document.getElementById('playBtn');
  const pauseBtn= document.getElementById('pauseBtn');
  const restartBtn = document.getElementById('restartBtn');
  const helpBtn = document.getElementById('helpBtn');
  const jumpT = document.getElementById('jumpT');
  const duckT = document.getElementById('duckT');
  const helpT = document.getElementById('helpT');

  function showToast(html){ toast.innerHTML = html; toast.classList.add('show'); setTimeout(()=>toast.classList.remove('show'), 2200); }

  /* ---------- Game constants ---------- */
  const H = () => wrap.clientHeight;
  const W = () => wrap.clientWidth;
  const GROUND_Y = () => H() - 48;
  const PLAYER = {
    x: 120, y: 0, w: 38, h: 46,
    vy: 0, onGround: true, duck: false,
    charRun: "üèÉ‚Äç‚ôÄÔ∏è", charDuck:"üßé‚Äç‚ôÄÔ∏è", charAir:"ü§∏‚Äç‚ôÄÔ∏è",
    airlift: false, airTimer: 0
  };

  const GRAVITY = 1600;         // px/s^2
  const JUMP_V  = -640;         // initial jump velocity (px/s)
  const DUCK_H  = 30;           // ducking height
  const MAX_LIVES = 3;
  const START_SPEED = 360;      // world scroll speed px/s
  const MAX_SPEED   = 720;

  const SPAWN_BASE = 1050;      // ms base between spawns
  const SPAWN_VAR  = 600;       // add randomness

  /* Obstacles:
     type: 'barricade' (jump), 'beam' (duck), 'hole' (needs jump OR HELP)
  */
  function makeObstacle(){
    const r = Math.random();
    if (r < 0.5) return {kind:'barricade', w: 40, h: 38, emoji:'üöß', y: GROUND_Y()-38};
    if (r < 0.78) return {kind:'beam', w: 70, h: 24, emoji:'üèóÔ∏è', y: GROUND_Y()-110};
    // hole: render as pit, collision if feet at/under ground inside x span
    const width = 120 + Math.random()*80;
    return {kind:'hole', w: width, h: 20, emoji:'üï≥Ô∏è', y: GROUND_Y()};
  }

  /* ---------- State ---------- */
  let best = Number(localStorage.getItem('runner_best')||0); bestEl.textContent = best;
  let lives = MAX_LIVES;
  let score = 0;
  let speed = START_SPEED;
  let paused = true;
  let gameOver = false;

  let obstacles = [];
  let lastSpawn = 0;
  let spawnDelay = SPAWN_BASE;

  let lastTime = 0;

  let helpCharges = 2;      // total uses
  let helpCooldown = 0;     // ms cooldown timer

  /* ---------- Helpers ---------- */
  function reset(){
    lives = MAX_LIVES; score = 0; speed = START_SPEED;
    obstacles.length = 0; lastSpawn = 0; spawnDelay = SPAWN_BASE;
    paused = true; gameOver = false; helpCharges = 2; helpCooldown = 0;
    PLAYER.y = GROUND_Y() - PLAYER.h; PLAYER.vy = 0; PLAYER.onGround = true; PLAYER.duck = false; PLAYER.airlift = false; PLAYER.airTimer = 0;
    render(0); updateUI();
  }
  function updateUI(){
    scoreEl.textContent = Math.floor(score);
    const hats = "‚õëÔ∏è".repeat(lives) || "‚Äî";
    livesEl.textContent = hats;
    speedEl.textContent = (speed/START_SPEED).toFixed(1)+"x";
    helpBtn.textContent = `üÜò Help (Crane) ${helpCharges>0 ? `¬∑ ${helpCharges}` : helpCooldown>0 ? `¬∑ cooldown` : ''}`;
  }

  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
  function rnd(min,max){ return Math.random()*(max-min)+min; }

  function spawnIfNeeded(dt){
    lastSpawn += dt;
    if (lastSpawn >= spawnDelay){
      lastSpawn = 0;
      // do not spawn impossible combos immediately after hole
      const last = obstacles[obstacles.length-1];
      const o = makeObstacle();
      if (last && last.kind==='hole' && o.kind==='hole'){ o.kind='barricade'; o.w=40; o.h=38; o.emoji='üöß'; o.y=GROUND_Y()-38; }
      o.x = W() + 20;
      obstacles.push(o);
      spawnDelay = SPAWN_BASE - clamp((speed-START_SPEED)*0.8, 0, 500) + rnd(0, SPAWN_VAR);
    }
  }

  function rectsOverlap(ax,ay,aw,ah, bx,by,bw,bh){
    return ax < bx+bw && ax+aw > bx && ay < by+bh && ay+ah > by;
  }

  /* ---------- Input ---------- */
  function jump(){
    if (gameOver || paused) return;
    if (PLAYER.onGround && !PLAYER.airlift){
      PLAYER.vy = JUMP_V;
      PLAYER.onGround = false;
    }
  }
  function setDuck(on){
    if (gameOver || paused) return;
    PLAYER.duck = on && PLAYER.onGround && !PLAYER.airlift;
  }
  function tryHelp(){
    if (gameOver || paused) return;
    if (helpCharges<=0 || helpCooldown>0 || PLAYER.airlift) return;
    // Only useful if a hole is near (but allow anytime)
    PLAYER.airlift = true;
    PLAYER.airTimer = 1100; // ms
    helpCharges--;
    helpCooldown = 3500; // ms
    showToast("ü™ù Crane lifting‚Ä¶");
  }

  document.addEventListener('keydown', e=>{
    if (e.code==='Space' || e.code==='ArrowUp'){ e.preventDefault(); jump(); }
    if (e.code==='ArrowDown'){ e.preventDefault(); setDuck(true); }
    if (e.key==='h' || e.key==='H'){ tryHelp(); }
    if (e.key==='p' || e.key==='P'){ togglePause(); }
    if (e.key==='r' || e.key==='R'){ reset(); paused=false; }
  });
  document.addEventListener('keyup', e=>{
    if (e.code==='ArrowDown'){ setDuck(false); }
  });

  // Touch buttons
  jumpT.onclick = jump;
  duckT.onpointerdown = ()=> setDuck(true);
  duckT.onpointerup   = ()=> setDuck(false);
  helpT.onclick = tryHelp;

  playBtn.onclick = ()=>{ if (gameOver) reset(); paused=false; };
  pauseBtn.onclick= ()=> togglePause();
  restartBtn.onclick=()=>{ reset(); paused=false; };
  helpBtn.onclick = tryHelp;

  function togglePause(){ if (gameOver) return; paused = !paused; if (!paused){ lastTime = performance.now(); requestAnimationFrame(tick); } }

  /* ---------- Update ---------- */
  function tick(ts){
    if (paused) return;
    if (!lastTime) lastTime = ts;
    const dt = (ts - lastTime); // ms
    lastTime = ts;

    update(dt/1000);
    render(ts);
    requestAnimationFrame(tick);
  }

  function update(dt){
    // speed ramp
    speed = clamp(speed + dt*8, START_SPEED, MAX_SPEED);
    score += dt* (speed/40);

    // cooldowns & timers
    if (helpCooldown>0){ helpCooldown = Math.max(0, helpCooldown - dt*1000); }
    if (PLAYER.airlift){
      PLAYER.airTimer -= dt*1000;
      // lift up and carry forward visually (we‚Äôll just hold player and move world)
      const liftY = 120; // pixels above ground
      PLAYER.y = GROUND_Y() - PLAYER.h - liftY;
      if (PLAYER.airTimer <= 0){
        PLAYER.airlift = false;
        PLAYER.onGround = false; // drop back, will land
        showToast("‚úÖ Safe across");
      }
    } else {
      // gravity & duck
      const targetH = PLAYER.duck ? DUCK_H : 46;
      if (PLAYER.h !== targetH){
        // smooth-ish snap
        PLAYER.h = targetH;
        if (PLAYER.onGround) PLAYER.y = GROUND_Y() - PLAYER.h;
      }

      // apply gravity
      PLAYER.vy += GRAVITY * dt;
      PLAYER.y  += PLAYER.vy * dt;

      // ground collision
      const gy = GROUND_Y() - PLAYER.h;
      if (PLAYER.y >= gy){
        PLAYER.y = gy; PLAYER.vy = 0; PLAYER.onGround = true;
      }
    }

    // move obstacles
    for (const o of obstacles){
      o.x -= speed * dt;
    }
    // remove off-screen
    obstacles = obstacles.filter(o => o.x + o.w > -40);

    // spawn new
    spawnIfNeeded(dt*1000);

    // collisions
    for (const o of obstacles){
      if (o.kind === 'hole'){
        // Check if player is over hole at ground level and not airlifted
        const pxCenter = PLAYER.x + PLAYER.w/2;
        const inHole = pxCenter > o.x && pxCenter < o.x + o.w;
        const feetAtGround = PLAYER.y + PLAYER.h >= GROUND_Y() - 2;
        if (!PLAYER.airlift && inHole && feetAtGround){
          loseLife();
          break;
        }
      } else if (o.kind === 'barricade'){
        const hit = rectsOverlap(PLAYER.x, PLAYER.y, PLAYER.w, PLAYER.h, o.x, o.y, o.w, o.h);
        if (hit){ loseLife(); break; }
      } else if (o.kind === 'beam'){
        // only hits if not ducking and y overlaps beam
        const hit = rectsOverlap(PLAYER.x, PLAYER.y, PLAYER.w, PLAYER.h, o.x, o.y, o.w, o.h) && !PLAYER.duck;
        if (hit){ loseLife(); break; }
      }
    }

    // update UI
    updateUI();
  }

  function loseLife(){
    lives--;
    showToast(lives>0 ? "üí• Ouch! ‚àí1 life" : "üí• Out of lives");
    // brief invuln/reset position
    PLAYER.y = GROUND_Y() - PLAYER.h; PLAYER.vy = 0; PLAYER.onGround = true; PLAYER.duck = false; PLAYER.airlift=false; PLAYER.airTimer=0;
    // clear near obstacles to prevent instant repeat
    obstacles = obstacles.filter(o => o.x > PLAYER.x + 40);
    if (lives <= 0){
      endGame();
    }
  }

  function endGame(){
    gameOver = true; paused = true;
    if (Math.floor(score) > best){ best = Math.floor(score); localStorage.setItem('runner_best', String(best)); }
    bestEl.textContent = best;
    showToast(`Game over ‚Äî Score <b>${Math.floor(score)}</b> ¬∑ Best <b>${best}</b>`);
  }

  /* ---------- Render ---------- */
  function render(ts){
    const w = W(), h = H();
    ctx.clearRect(0,0,w,h);

    // background gridlines (very subtle)
    ctx.save();
    ctx.globalAlpha = 0.06;
    ctx.strokeStyle = '#8ab3ff';
    ctx.lineWidth = 1;
    const step = 24;
    for (let x= (ts/80)%step; x < w; x+=step){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }
    for (let y= 0; y < h; y+=step){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }
    ctx.restore();

    // ground
    ctx.strokeStyle = '#2a3b55'; ctx.lineWidth = 3;
    ctx.beginPath(); ctx.moveTo(0, GROUND_Y()+0.5); ctx.lineTo(w, GROUND_Y()+0.5); ctx.stroke();

    // draw potholes (as gaps + emoji label)
    for (const o of obstacles){
      if (o.kind === 'hole'){
        ctx.save();
        ctx.fillStyle = '#07101f';
        ctx.fillRect(o.x, o.y, o.w, 30);
        ctx.globalAlpha = 0.7;
        ctx.font = '20px system-ui, Apple Color Emoji, Segoe UI Emoji, Noto Color Emoji';
        ctx.fillText('üï≥Ô∏è', o.x + o.w/2 - 10, o.y + 22);
        ctx.restore();
      }
    }

    // draw obstacles (barricade / beam)
    ctx.font = '32px system-ui, Apple Color Emoji, Segoe UI Emoji, Noto Color Emoji';
    for (const o of obstacles){
      if (o.kind === 'barricade'){
        ctx.fillText(o.emoji, o.x, o.y + o.h);
      } else if (o.kind === 'beam'){
        ctx.fillText(o.emoji, o.x, o.y + o.h);
      }
    }

    // player (with crane airlift)
    ctx.save();
    if (PLAYER.airlift){
      // rope + hook
      const hookX = PLAYER.x + PLAYER.w/2, hookY = 40;
      ctx.strokeStyle = '#5aa6ff'; ctx.lineWidth = 2; ctx.globalAlpha=0.7;
      ctx.beginPath(); ctx.moveTo(hookX, hookY); ctx.lineTo(hookX, PLAYER.y + 6); ctx.stroke();
      ctx.globalAlpha=1; ctx.font='28px system-ui, Apple Color Emoji, Segoe UI Emoji, Noto Color Emoji';
      ctx.fillText('ü™ù', hookX-14, hookY+8);
    }
    // character
    ctx.font = (PLAYER.duck ? '34px' : '36px') + ' system-ui, Apple Color Emoji, Segoe UI Emoji, Noto Color Emoji';
    const char = PLAYER.onGround ? (PLAYER.duck ? PLAYER.charDuck : PLAYER.charRun) : PLAYER.charAir;
    ctx.fillText(char, PLAYER.x, PLAYER.y + PLAYER.h);
    ctx.restore();

    // overlay when paused/game over
    if (paused){
      ctx.save();
      ctx.fillStyle = 'rgba(11,18,32,.55)';
      ctx.fillRect(0,0,w,h);
      ctx.fillStyle = '#e2e8f0';
      ctx.font = '700 22px system-ui, -apple-system';
      ctx.textAlign = 'center';
      ctx.fillText(gameOver ? 'Game Over' : 'Paused', w/2, h/2 - 10);
      ctx.font = '14px system-ui, -apple-system';
      ctx.fillText('Space/‚Üë Jump ‚Ä¢ ‚Üì Duck ‚Ä¢ H Help ‚Ä¢ P Pause ‚Ä¢ R Restart', w/2, h/2 + 16);
      ctx.restore();
    }
  }

  /* ---------- Boot ---------- */
  reset();
  // Auto-run when clicking Play
  playBtn.focus();
  // Start loop when unpaused
  const startLoop = () => { if (!paused){ lastTime = performance.now(); requestAnimationFrame(tick); } };
  const origPlay = playBtn.onclick;
  playBtn.onclick = () => { origPlay(); startLoop(); };
  pauseBtn.onclick = () => { togglePause(); startLoop(); };
  restartBtn.onclick = () => { reset(); paused=false; startLoop(); };
  helpBtn.onclick = () => { tryHelp(); };
  // Start loop if user presses any gameplay key
  document.addEventListener('keydown', () => startLoop(), { once:true });
})();
</script>
</body>
</html>
