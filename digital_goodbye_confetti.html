<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>üë∑‚Äç‚ôÄÔ∏è Farewell Runner ‚Äî Irfana</title>
<style>
  :root{
    --text:#e2e8f0; --muted:#9fb0c3; --border:#223148; --card:#0b1220cc; --pill:#0e1728;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0}
  body{
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, "Helvetica Neue", Arial;
    color:var(--text);
    display:grid; gap:14px; place-items:center; align-content:start;
    background:#0a1424 center/cover no-repeat fixed;   /* replaced with your photo by JS */
  }
  /* dark soft overlay so text stays readable over photos */
  body::before{
    content:""; position:fixed; inset:0; pointer-events:none; z-index:-1;
    background: radial-gradient(1100px 700px at 12% 10%, rgba(9,14,24,.55), rgba(6,10,18,.86));
  }

  .card{
    width:min(92vw, 900px);
    background:var(--card); border:1px solid var(--border);
    border-radius:18px; padding:18px 18px 12px;
    box-shadow:0 22px 48px rgba(0,0,0,.38), inset 0 1px 0 rgba(255,255,255,.06);
    backdrop-filter: blur(10px);
  }
  h1{margin:0 0 6px; font-size:clamp(22px,4.8vw,32px)}
  .msg{margin:0 0 10px; color:var(--muted); font-size:clamp(14px,2.6vw,16px)}
  .legend{margin:2px 0 0; font-size:12px; opacity:.9}

  .wrap{
    position:relative; width:min(96vw, 980px); aspect-ratio: 9/3;
    border:1px solid var(--border); border-radius:16px; overflow:hidden;
    background:linear-gradient(#0c1526, #0a1220);
    box-shadow:0 22px 60px rgba(0,0,0,.42);
  }
  canvas{width:100%; height:100%; display:block}

  .hud, .controls{
    position:absolute; z-index:3; display:flex; gap:8px; flex-wrap:wrap; align-items:center;
    background:#0b1220bf; border:1px solid var(--border); border-radius:12px; padding:6px 8px; font-size:12px; backdrop-filter:blur(8px)
  }
  .hud{left:10px; top:10px}
  .controls{right:10px; top:10px}
  .pill{padding:4px 8px; border:1px solid #2b3b52; background:var(--pill); border-radius:10px}
  .accent{border-color:#2e5a4c}

  .controls button, .row button{
    appearance:none; border:1px solid #334155; background:#0b1220; color:var(--text);
    padding:8px 10px; border-radius:10px; font-weight:600; cursor:pointer
  }
  .controls button:hover, .row button:hover{border-color:#475569}

  .touch{position:absolute; inset:auto 0 10px 0; z-index:3; display:flex; gap:10px; justify-content:center}
  .touch button{min-width:92px; padding:12px 14px; border-radius:12px; background:#0b1220cc}

  .toast{
    position:absolute; left:50%; bottom:12px; transform:translateX(-50%);
    background:#0b1220cc; border:1px solid var(--border); border-radius:12px; padding:8px 12px; font-weight:700;
    box-shadow:0 12px 30px rgba(0,0,0,.35); backdrop-filter: blur(8px);
    opacity:0; transition:opacity .25s, transform .25s; pointer-events:none; z-index:4
  }
  .toast.show{opacity:1; transform:translateX(-50%) translateY(-6px)}

  .row{display:flex; gap:10px; flex-wrap:wrap}

  /* Feedback modal */
  .modal{position:fixed; inset:0; z-index:20; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.45); padding:18px}
  .modal.open{display:flex}
  .modal-card{width:min(92vw,620px); background:#0b1220; border:1px solid var(--border); border-radius:16px; padding:18px; box-shadow:0 24px 60px rgba(0,0,0,.5)}
  .modal-card h2{margin:0 0 10px; font-size:20px}
  textarea{width:100%; min-height:140px; background:#0f172a; color:var(--text); border:1px solid #334155; border-radius:12px; padding:10px; font:inherit}
</style>
</head>
<body>
  <div class="card">
    <div style="display:flex; align-items:center; justify-content:space-between; gap:8px;">
      <div>
        <h1>Thank you, team!</h1>
        <p class="msg">It‚Äôs been a privilege to build, iterate, and ship with you. Wishing you smooth workflows and zero clashes ahead.</p>
        <p class="legend">Controls: <b>Space/‚Üë Jump</b>, <b>‚Üì Duck</b>, <b>H Help (crane)</b>, <b>P Pause</b>, <b>R Restart</b>.</p>
      </div>
      <button id="feedbackBtn">üí¨ Leave feedback</button>
    </div>
  </div>

  <div class="wrap" id="wrap">
    <canvas id="game" aria-label="Construction runner game"></canvas>

    <div class="hud">
      <span class="pill">Score: <b id="score">0</b></span>
      <span class="pill">Speed: <b id="speed">1.0x</b></span>
      <span class="pill">Lives: <b id="lives">‚õëÔ∏è‚õëÔ∏è‚õëÔ∏è</b></span>
      <span class="pill accent">Best: <b id="best">0</b></span>
    </div>

    <div class="controls">
      <button id="playBtn">‚ñ∂Ô∏è Play</button>
      <button id="helpBtn">üÜò Help (Crane)</button>
      <button id="pauseBtn">‚è∏Ô∏è Pause</button>
      <button id="restartBtn">üîÅ Restart</button>
    </div>

    <div class="touch">
      <button id="jumpT">‚§¥Ô∏è Jump</button>
      <button id="duckT">‚Üß Duck</button>
      <button id="helpT">üÜò Help</button>
    </div>

    <div class="toast" id="toast"></div>
  </div>

  <!-- Feedback Modal -->
  <div class="modal" id="modal">
    <div class="modal-card">
      <h2>üí¨ Share your feedback</h2>
      <textarea id="fbText" placeholder="Write a quick note..."></textarea>
      <div class="row" style="justify-content:flex-end">
        <button id="cancel">Cancel</button>
        <button id="send">Send</button>
      </div>
    </div>
  </div>

  <!-- Hidden iframe for Google Form POST -->
  <iframe name="gform-target" style="display:none"></iframe>

<script>
/* -------------------------------------------------------------
   Background image (your 1.jpeg or ?bg=...)
------------------------------------------------------------- */
{
  const qs = new URLSearchParams(location.search);
  const bg = qs.get('bg') || "1.jpeg";
  const url = /^https?:\/\//.test(bg) ? bg : bg;
  document.body.style.backgroundImage = `url('${url}')`;
}

/* -------------------------------------------------------------
   Canvas & HUD
------------------------------------------------------------- */
const canvas = document.getElementById('game');
const wrap = document.getElementById('wrap');
const ctx = canvas.getContext('2d', { alpha:true });

function resize(){
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
  const w = wrap.clientWidth, h = wrap.clientHeight;
  canvas.width = Math.floor(w*dpr); canvas.height = Math.floor(h*dpr);
  canvas.style.width = w+"px"; canvas.style.height = h+"px";
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
resize(); addEventListener('resize', resize);

const scoreEl = document.getElementById('score');
const speedEl = document.getElementById('speed');
const livesEl = document.getElementById('lives');
const bestEl  = document.getElementById('best');
const toast   = document.getElementById('toast');
function showToast(t){ toast.innerHTML=t; toast.classList.add('show'); setTimeout(()=>toast.classList.remove('show'), 2000); }

/* -------------------------------------------------------------
   Controls
------------------------------------------------------------- */
const playBtn = document.getElementById('playBtn');
const pauseBtn= document.getElementById('pauseBtn');
const restartBtn=document.getElementById('restartBtn');
const helpBtn  = document.getElementById('helpBtn');
const jumpT    = document.getElementById('jumpT');
const duckT    = document.getElementById('duckT');
const helpT    = document.getElementById('helpT');

/* -------------------------------------------------------------
   Runner sprite / fallback vector
------------------------------------------------------------- */
const SPRITE_CONFIG = {
  src: "worker_run.png",  // PLACE THIS PNG IN YOUR REPO (8 frames, 1 row)
  cols: 8, rows: 1,
  frameW: 128, frameH: 128,    // change if your sheet uses different frame size
  scale: 0.66                  // overall on-canvas scale
};
const runnerImg = new Image();
let spriteLoaded = false;
runnerImg.onload = ()=> spriteLoaded = true;
runnerImg.onerror = ()=> spriteLoaded = false;
runnerImg.src = SPRITE_CONFIG.src;

/* -------------------------------------------------------------
   Game constants
------------------------------------------------------------- */
const H = ()=> wrap.clientHeight, W = ()=> wrap.clientWidth;
const GROUND = ()=> H()-50;

const PLAYER = {
  x: 120, y: 0, w: 46, h: 56,    // visible bounds (slightly bigger)
  vy: 0, onGround:true, duck:false,
  airlift:false, airTimer:0,
  frame:0, frameTime:0           // sprite animation
};

const GRAVITY = 1600, JUMP_V = -640, DUCK_H = 38;
const MAX_LIVES = 3;
const START_SPEED = 360, MAX_SPEED = 760;
const SPAWN_BASE = 1050, SPAWN_VAR = 600;

/* Obstacles in vector style (no emoji) */
function makeObstacle(){
  const r = Math.random();
  if (r < 0.5) return {kind:'barricade', w:48, h:40, x:0, y:0};
  if (r < 0.8) return {kind:'beam',      w:84, h:22, x:0, y:0};
  const width = 120 + Math.random()*100;
  return {kind:'hole', w:width, h:24, x:0, y:0};
}

/* -------------------------------------------------------------
   State
------------------------------------------------------------- */
let best = Number(localStorage.getItem('runner_best')||0); bestEl.textContent = best;
let lives, score, speed, paused, gameOver, obstacles, lastSpawn, spawnDelay, lastTime;
let helpCharges, helpCooldown, dust=[];

function reset(){
  lives=MAX_LIVES; score=0; speed=START_SPEED; paused=true; gameOver=false;
  obstacles=[]; lastSpawn=0; spawnDelay=SPAWN_BASE; helpCharges=2; helpCooldown=0;
  dust.length=0;
  PLAYER.y = GROUND()-PLAYER.h; PLAYER.vy=0; PLAYER.onGround=true; PLAYER.duck=false; PLAYER.airlift=false; PLAYER.airTimer=0; PLAYER.frame=0; PLAYER.frameTime=0;
  render(0); updateUI();
}
reset();

/* -------------------------------------------------------------
   UI helpers
------------------------------------------------------------- */
function updateUI(){
  scoreEl.textContent = Math.floor(score);
  livesEl.textContent = "‚õëÔ∏è".repeat(lives) || "‚Äî";
  speedEl.textContent = (speed/START_SPEED).toFixed(1)+"x";
  helpBtn.textContent = `üÜò Help (Crane) ${helpCharges>0 ? `¬∑ ${helpCharges}` : helpCooldown>0 ? `¬∑ cooldown` : ''}`;
}

/* -------------------------------------------------------------
   Input
------------------------------------------------------------- */
function jump(){ if (!paused && !gameOver && PLAYER.onGround && !PLAYER.airlift){ PLAYER.vy=JUMP_V; PLAYER.onGround=false; } }
function setDuck(on){ if (!paused && !gameOver && PLAYER.onGround && !PLAYER.airlift){ PLAYER.duck=on; } }
function tryHelp(){
  if (paused||gameOver) return;
  if (helpCharges<=0 || helpCooldown>0 || PLAYER.airlift) return;
  PLAYER.airlift=true; PLAYER.airTimer=1100; helpCharges--; helpCooldown=3500; showToast("ü™ù Crane lifting‚Ä¶");
}

document.addEventListener('keydown', e=>{
  if (e.code==='Space' || e.code==='ArrowUp'){ e.preventDefault(); jump(); }
  if (e.code==='ArrowDown'){ e.preventDefault(); setDuck(true); }
  if (e.key==='h' || e.key==='H'){ tryHelp(); }
  if (e.key==='p' || e.key==='P'){ togglePause(); }
  if (e.key==='r' || e.key==='R'){ reset(); paused=false; startLoop(); }
});
document.addEventListener('keyup', e=>{ if (e.code==='ArrowDown'){ setDuck(false); } });
jumpT.onclick = jump; duckT.onpointerdown=()=>setDuck(true); duckT.onpointerup=()=>setDuck(false); helpT.onclick=tryHelp;

playBtn.onclick = ()=>{ if (gameOver) reset(); paused=false; startLoop(); };
pauseBtn.onclick= ()=> togglePause();
restartBtn.onclick=()=>{ reset(); paused=false; startLoop(); };
helpBtn.onclick = tryHelp;

function togglePause(){ if (gameOver) return; paused = !paused; if (!paused) startLoop(); }

/* -------------------------------------------------------------
   Simulation
------------------------------------------------------------- */
function rectsOverlap(ax,ay,aw,ah,bx,by,bw,bh){ return ax<bx+bw && ax+aw>bx && ay<by+bh && ay+ah>by; }

function spawnIfNeeded(ms){
  lastSpawn += ms;
  if (lastSpawn >= spawnDelay){
    lastSpawn=0;
    const o = makeObstacle();
    o.x = W()+20;
    o.y = (o.kind==='barricade') ? GROUND()-o.h :
          (o.kind==='beam')     ? GROUND()-110 :
                                   GROUND();
    obstacles.push(o);
    spawnDelay = SPAWN_BASE - Math.min(520, (speed-START_SPEED)*0.8) + Math.random()*SPAWN_VAR;
  }
}

function addDust(){
  // small grounded dust puffs when running
  if (!PLAYER.onGround || PLAYER.airlift) return;
  if (Math.random()<0.5) return;
  dust.push({x:PLAYER.x+8+Math.random()*12, y:GROUND()-6, r:2+Math.random()*2, a:.35, vx:-speed*0.004, vy:-15-Math.random()*12});
  if (dust.length>60) dust.shift();
}

function update(dt){
  speed = Math.min(MAX_SPEED, speed + dt*8);
  score += dt * (speed/40);
  if (helpCooldown>0) helpCooldown = Math.max(0, helpCooldown - dt*1000);

  if (PLAYER.airlift){
    PLAYER.airTimer -= dt*1000;
    const lift = 120;
    PLAYER.y = GROUND() - PLAYER.h - lift;
    if (PLAYER.airTimer<=0){ PLAYER.airlift=false; PLAYER.onGround=false; showToast("‚úÖ Safe across"); }
  }else{
    const targetH = PLAYER.duck? DUCK_H : 56;
    if (PLAYER.h !== targetH){ PLAYER.h = targetH; if (PLAYER.onGround) PLAYER.y = GROUND()-PLAYER.h; }
    PLAYER.vy += GRAVITY*dt; PLAYER.y += PLAYER.vy*dt;
    const gy = GROUND()-PLAYER.h;
    if (PLAYER.y >= gy){ PLAYER.y=gy; PLAYER.vy=0; PLAYER.onGround=true; }
  }

  for (const o of obstacles) o.x -= speed*dt;
  obstacles = obstacles.filter(o=> o.x + o.w > -40);

  spawnIfNeeded(dt*1000);
  addDust();

  // collisions
  for (const o of obstacles){
    if (o.kind==='hole'){
      const center = PLAYER.x + PLAYER.w/2;
      const inHole = center>o.x && center<o.x+o.w;
      const feetGround = PLAYER.y + PLAYER.h >= GROUND()-2;
      if (!PLAYER.airlift && inHole && feetGround){ loseLife(); break; }
    } else if (o.kind==='barricade'){
      if (rectsOverlap(PLAYER.x,PLAYER.y,PLAYER.w,PLAYER.h, o.x,o.y,o.w,o.h)){ loseLife(); break; }
    } else if (o.kind==='beam'){
      if (rectsOverlap(PLAYER.x,PLAYER.y,PLAYER.w,PLAYER.h, o.x,o.y,o.w,o.h) && !PLAYER.duck){ loseLife(); break; }
    }
  }

  updateUI();
}

function loseLife(){
  lives--;
  showToast(lives>0? "üí• Ouch! ‚àí1 life" : "üí• Out of lives");
  PLAYER.y=GROUND()-PLAYER.h; PLAYER.vy=0; PLAYER.onGround=true; PLAYER.duck=false; PLAYER.airlift=false; PLAYER.airTimer=0;
  obstacles = obstacles.filter(o=> o.x > PLAYER.x + 46);
  if (lives<=0) endGame();
}

function endGame(){
  gameOver=true; paused=true;
  if (Math.floor(score) > best){ best=Math.floor(score); localStorage.setItem('runner_best', String(best)); }
  bestEl.textContent = best;
  showToast(`Game over ‚Äî Score <b>${Math.floor(score)}</b> ¬∑ Best <b>${best}</b>`);
}

/* -------------------------------------------------------------
   Rendering (parallax grid, vector obstacles, sprite runner)
------------------------------------------------------------- */
function drawGrid(ts){
  ctx.save(); ctx.globalAlpha=.06; ctx.strokeStyle='#8ab3ff'; ctx.lineWidth=1;
  const step=24, xoff=(ts/80)%step;
  for(let x=xoff; x<W(); x+=step){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H()); ctx.stroke(); }
  for(let y=0; y<H(); y+=step){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W(),y); ctx.stroke(); }
  ctx.restore();
}
function drawGround(){
  ctx.strokeStyle = '#2a3b55'; ctx.lineWidth=3;
  ctx.beginPath(); ctx.moveTo(0,GROUND()+.5); ctx.lineTo(W(),GROUND()+.5); ctx.stroke();
}
function drawHole(o){
  const y = o.y, h = 30;
  ctx.save();
  const grad = ctx.createLinearGradient(0,y,0,y+h);
  grad.addColorStop(0,'#07101f'); grad.addColorStop(1,'#000814');
  ctx.fillStyle = grad; ctx.fillRect(o.x, y, o.w, h);
  ctx.restore();
}
function drawBarricade(o){
  ctx.save();
  // frame
  ctx.fillStyle='#1a263a'; ctx.fillRect(o.x, o.y, o.w, o.h);
  // stripes
  const stripeW = 10;
  for(let x=o.x; x<o.x+o.w+o.h; x+=stripeW){
    ctx.fillStyle = ((Math.floor((x-o.x)/stripeW)%2)===0) ? '#ffc43d' : '#1e293b';
    ctx.beginPath();
    ctx.moveTo(x, o.y);
    ctx.lineTo(x+stripeW, o.y);
    ctx.lineTo(x, o.y+o.h);
    ctx.closePath();
    ctx.fill();
  }
  ctx.strokeStyle='#2b3b52'; ctx.lineWidth=2; ctx.strokeRect(o.x+0.5, o.y+0.5, o.w-1, o.h-1);
  ctx.restore();
}
function drawBeam(o){
  ctx.save();
  const r=8;
  ctx.fillStyle='#ffd166';
  ctx.beginPath();
  ctx.moveTo(o.x+r, o.y);
  ctx.lineTo(o.x+o.w-r, o.y);
  ctx.quadraticCurveTo(o.x+o.w, o.y, o.x+o.w, o.y+r);
  ctx.lineTo(o.x+o.w, o.y+o.h-r);
  ctx.quadraticCurveTo(o.x+o.w, o.y+o.h, o.x+o.w-r, o.y+o.h);
  ctx.lineTo(o.x+r, o.y+o.h);
  ctx.quadraticCurveTo(o.x, o.y+o.h, o.x, o.y+o.h-r);
  ctx.lineTo(o.x, o.y+r);
  ctx.quadraticCurveTo(o.x, o.y, o.x+r, o.y);
  ctx.fill();
  // hazard diagonal
  ctx.strokeStyle='#2e3a54'; ctx.lineWidth=3; ctx.globalAlpha=.5;
  for(let x=o.x-12; x<o.x+o.w+o.h; x+=14){
    ctx.beginPath(); ctx.moveTo(x, o.y+o.h); ctx.lineTo(x+28, o.y); ctx.stroke();
  }
  ctx.restore();
}
function drawDust(){
  ctx.save();
  for(const p of dust){
    p.x += p.vx; p.y += p.vy*0.016; p.vy += 22*0.016; p.a -= 0.01;
    ctx.globalAlpha=Math.max(0,p.a);
    ctx.fillStyle='#96a7c3';
    ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill();
  }
  dust = dust.filter(p=>p.a>0);
  ctx.restore();
}

function drawRunner(ts){
  // drop shadow
  ctx.save();
  const shadowY = GROUND()+2;
  ctx.globalAlpha = 0.25;
  ctx.fillStyle = '#000';
  const shW = 28, shH = 6;
  ctx.beginPath();
  ctx.ellipse(PLAYER.x+PLAYER.w*0.45, shadowY, shW, shH, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();

  // sprite or fallback vector
  if (spriteLoaded){
    // animate frames only when moving on ground
    const frameRate = 12; // FPS
    if (PLAYER.onGround && !paused && !gameOver && !PLAYER.airlift){
      PLAYER.frameTime += (ts - (drawRunner.prevTs||ts));
      const frameDur = 1000/frameRate;
      while (PLAYER.frameTime >= frameDur){ PLAYER.frame=(PLAYER.frame+1)%SPRITE_CONFIG.cols; PLAYER.frameTime-=frameDur; }
    } else {
      // airborne: hold a mid frame
      PLAYER.frame = 2;
    }
    drawRunner.prevTs = ts;

    const fw = SPRITE_CONFIG.frameW, fh = SPRITE_CONFIG.frameH;
    const scale = SPRITE_CONFIG.scale * (PLAYER.duck ? 0.85 : 1);
    const dw = fw*scale, dh = fh*scale;

    const sx = PLAYER.frame*fw, sy = 0;
    const dx = PLAYER.x - 6, dy = PLAYER.y + PLAYER.h - dh;  // align feet to ground
    ctx.imageSmoothingEnabled = true;
    ctx.drawImage(runnerImg, sx, sy, fw, fh, dx, dy, dw, dh);
  } else {
    // fallback flat vector runner
    ctx.save();
    ctx.translate(PLAYER.x+PLAYER.w*0.3, PLAYER.y+PLAYER.h);
    // body
    ctx.strokeStyle='#f1f5f9'; ctx.lineWidth=3;
    // head (helmet)
    ctx.fillStyle='#ffd166';
    ctx.beginPath(); ctx.arc(0,-28,8,0,Math.PI*2); ctx.fill();
    // torso
    ctx.beginPath(); ctx.moveTo(0,-20); ctx.lineTo(0,-6); ctx.stroke();
    // legs (simple gait)
    const t = (ts/120)%Math.PI;
    const a = Math.sin(t)*6;
    ctx.beginPath(); ctx.moveTo(0,-6); ctx.lineTo(8+a,8); ctx.moveTo(0,-6); ctx.lineTo(-8-a,8); ctx.stroke();
    // arms
    ctx.beginPath(); ctx.moveTo(0,-16); ctx.lineTo(10-a,-6); ctx.moveTo(0,-16); ctx.lineTo(-10+a,-8); ctx.stroke();
    ctx.restore();
  }

  drawDust();
}

function render(ts){
  ctx.clearRect(0,0,W(),H());
  drawGrid(ts);
  drawGround();

  // obstacles
  for(const o of obstacles){
    if (o.kind==='hole') drawHole(o);
    else if (o.kind==='barricade') drawBarricade(o);
    else drawBeam(o);
  }

  // crane rope when airlift
  if (PLAYER.airlift){
    const hx = PLAYER.x + PLAYER.w/2, hy = 40;
    ctx.strokeStyle='#5aa6ff'; ctx.globalAlpha=.7; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(hx,hy); ctx.lineTo(hx, PLAYER.y+8); ctx.stroke();
    ctx.globalAlpha=1; ctx.font='26px system-ui, Apple Color Emoji, Segoe UI Emoji, Noto Color Emoji';
    ctx.fillText('ü™ù', hx-13, hy+8);
  }

  drawRunner(ts);

  if (paused){
    ctx.save();
    ctx.fillStyle='rgba(11,18,32,.55)'; ctx.fillRect(0,0,W(),H());
    ctx.fillStyle='#e2e8f0'; ctx.textAlign='center';
    ctx.font='700 22px system-ui'; ctx.fillText(gameOver?'Game Over':'Paused', W()/2, H()/2 - 8);
    ctx.font='14px system-ui';
    ctx.fillText('Space/‚Üë Jump ‚Ä¢ ‚Üì Duck ‚Ä¢ H Help ‚Ä¢ P Pause ‚Ä¢ R Restart', W()/2, H()/2 + 16);
    ctx.restore();
  }
}

/* -------------------------------------------------------------
   Loop
------------------------------------------------------------- */
let lastTs=0;
function tick(ts){
  if (paused) return;
  if (!lastTs) lastTs=ts;
  const dt=(ts-lastTs)/1000; lastTs=ts;
  update(dt); render(ts); requestAnimationFrame(tick);
}
function startLoop(){ if (!paused){ lastTs=performance.now(); requestAnimationFrame(tick); } }

/* -------------------------------------------------------------
   Feedback (Google Form direct submit)
------------------------------------------------------------- */
const modal=document.getElementById('modal');
const feedbackBtn=document.getElementById('feedbackBtn');
const cancelBtn=document.getElementById('cancel');
const sendBtn=document.getElementById('send');
const fbText=document.getElementById('fbText');

// Your form: https://docs.google.com/forms/d/e/1FAIpQLSepDMrPMO7QyUpuBlqOZFUDsvVUg6XtiYh0G2eYARxeD-3cMA/viewform?usp=pp_url&entry.1175385091=...
const GF_ACTION="https://docs.google.com/forms/d/e/1FAIpQLSepDMrPMO7QyUpuBlqOZFUDsvVUg6XtiYh0G2eYARxeD-3cMA/formResponse";
const GF_FIELD="entry.1175385091";

feedbackBtn.onclick=()=>{ modal.classList.add('open'); fbText.focus(); };
cancelBtn.onclick=()=> modal.classList.remove('open');
sendBtn.onclick=()=>{
  const v=fbText.value.trim();
  if(!v){ alert("Please write a quick note first."); return; }
  const form=document.createElement('form'); form.method='POST'; form.action=GF_ACTION; form.target='gform-target';
  const t=document.createElement('textarea'); t.name=GF_FIELD; t.value=`${v}\n\n‚Äî sent from: ${location.href}`;
  form.appendChild(t); document.body.appendChild(form); form.submit(); document.body.removeChild(form);
  alert("Thanks! Your feedback was sent ‚úÖ"); modal.classList.remove('open'); fbText.value="";
};

/* -------------------------------------------------------------
   Wire up pause/resume
------------------------------------------------------------- */
function togglePause(){ if (gameOver) return; paused = !paused; if (!paused) startLoop(); }
playBtn.addEventListener('click', ()=> startLoop());
pauseBtn.addEventListener('click', ()=> startLoop());
restartBtn.addEventListener('click', ()=> startLoop());
document.addEventListener('keydown', ()=> startLoop(), { once:true });

/* -------------------------------------------------------------
   Final helpers
------------------------------------------------------------- */
function endGame(){
  gameOver=true; paused=true;
  if (Math.floor(score) > best){ best=Math.floor(score); localStorage.setItem('runner_best', String(best)); }
  bestEl.textContent = best;
  showToast(`Game over ‚Äî Score <b>${Math.floor(score)}</b> ¬∑ Best <b>${best}</b>`);
}
</script>
</body>
</html>
